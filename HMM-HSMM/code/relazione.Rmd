---
title: 'Stock return: HMM and HSMM'
author: "Matteo Fasulo, Simone Flavio Paris, Matteo Sivoccia"
date: "18/12/2021"
output: 
  html_notebook:
    toc: yes
    toc_depth: 3
    number_sections: yes
    toc_float: yes
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
  pdf_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
    number_sections: yes
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
    number_sections: yes
    toc_float: yes
    theme: united
    highlight: tango
    code_folding: hide
---
# Introduzione

## Librerie
Pacchetti utilizzati:
```{r load, message=FALSE, warning=FALSE, paged.print=TRUE}
load(url("https://github.com/smoxy/DMANA-proj/blob/main/HMM-HSMM/code/Examples_L31.RData?raw=true"))
source("https://raw.githubusercontent.com/MatteoFasulo/Rare-Earth/main/R/util/coreFunctions.R")
loadPackages(c('ggplot2','gamlss','tidyverse','tidyquant','magrittr',
               'tseries','MVN','mhsmm','doParallel','pacman','gridExtra'))
rm(returns)
rm(pollution)
rm(stock.names)
pacman::p_loaded()
```

# Preprocessing e andamento
Trasformazione delle date e filtering in periodo della ricerca:
```{r prePocessing, message=FALSE, warning=FALSE, include=FALSE, paged.print=TRUE}
StockReturns %<>%
  mutate(Date=as.Date(StockReturns$Date,format="%d/%m/%Y"))

StockReturns2 <- StockReturns %>%
                  select(SP500,NASDAQ,ESTX50,FTSE,Date) %>%
                  filter(Date > "2003/01/01" & Date < "2016/06/23")
```

Restruct del df per graph con ggplot:
```{r ggplotGraph, message=FALSE, warning=FALSE, paged.print=TRUE}
dfStruct <- function(dataframe){
  dates <- dataframe$Date
  SP500 <- dataframe$SP500
  NASDAQ <- dataframe$NASDAQ
  FTSE <- dataframe$FTSE
  ESTX50 <- dataframe$ESTX50

  name <- rep(c("SP500","NASDAQ","FTSE","ESTX50"),times=c(nrow(dataframe),nrow(dataframe),nrow(dataframe),nrow(dataframe)))
  dates <- rep(dates, times=4)
  value <- rep(c(SP500,NASDAQ,FTSE,ESTX50))

  df <- data.frame("name"=name,
                       "date"=as.Date(dates,format="%d/%m/%Y"),
                       "value"=value)
  return(df)
}

Stocks <- dfStruct(StockReturns2)

Stocks %>%
  ggplot(., aes(x=date, y=value, group=name))+
    geom_line(size=.7, col="gray13") +
    scale_x_date(date_labels = "%Y", date_breaks="2 year") +
    facet_wrap(~ name, ncol = 1, scale = "free_y") +
    labs(title = "ESTX50, FTSE, NASDAQ & SP500 Chart",
         subtitle = "Multiple Stocks",
         y = "Return",
         x = "") +
    theme_tq()
```

# Statistiche descrittive
Summary statistics:
```{r summaryStats, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
Stocks %>%
  group_by(name) %>%
  summarise("Mean"=round(mean(value),3),
            "Std. dev"=sd(value),
            "Skewness"=skewness(value),
            "Kurtosis"=PerformanceAnalytics::kurtosis(value, method = 'excess'),
            "Jarqueâ€“Bera test (p-value)"
            =paste(round(as.double(jarque.bera.test(value)$statistic),1)," (",
                   as.double(jarque.bera.test(value)$p.value),")",sep=""))

```

## Verifica dei risultati ottenuti dalle statistiche descrittive

```{r plotsNormal, message=FALSE, warning=FALSE, paged.print=TRUE}
par(mfrow=c(1,3))
qqnorm(StockReturns2$NASDAQ)
qqline(StockReturns2$NASDAQ)
qqnorm(StockReturns2$ESTX50)
qqline(StockReturns2$ESTX50)
mvn(StockReturns2[,-c(1,4,5)],mvnTest="mardia",multivariatePlot="qq")
```

# HMM
## Parallel Bootstrap
```{r N-HMM, message=FALSE, warning=FALSE}
newDF <- StockReturns2[,-c(1,4,5)]
bootstrap.N.HMM = function(data, nclust, R){
  master = list()
  cores <- ifelse(detectCores()>6,
                  cores <- 6,
                  cores <- 4)
  cl <- makeCluster(cores)
  registerDoParallel(cl)
  master<-append(master,foreach(num = 2:nclust) %dopar% {
    require(mhsmm)

    hsmmAIC <- function(model){
      if (class(model)=='hmm'){
        m = model$K
      } else if (class(model)=='hsmm'){
        m = model$J
      }
      k = length(model$model$parms.emission)
      p = m^2 + (k*m) - 1
      logL = max(model$loglik)
      AIC = (2 * logL) + (2*p)
      return(AIC)
    }

    hsmmBIC <- function(model){
      if (class(model)=='hmm'){
        m = model$K
      } else if (class(model)=='hsmm'){
        m = model$J
      }
      nObs = length(model$yhat)
      k = length(model$model$parms.emission)
      p = (m^2 + (k*m)) - 1
      logL = max(model$loglik)
      BIC = (2 * logL) + (p*log(nObs))
      return(BIC)
    }

    initialization <- kmeans(data,num)
    kmeans.means <- initialization$centers
    km.means.list = list()
    sigma = list()
    for (n in 1:num){
      sigma[[n]] = cov(data[initialization$cluster==n,])
      km.means.list[[n]] = kmeans.means[n,]
    }
    K <- num
    start.val <- hmmspec(init = rep(1/K, K),
                         trans = matrix(1/K, nrow = K, ncol = K),
                         parms.emis = list(mu=km.means.list,
                                           sigma=sigma),
                         dens.emis = dmvnorm.hsmm)
    mod.hmm <- hmmfit(matrix(unlist(data),ncol=2),
                      start.val, mstep = mstep.mvnorm)
    mu.boot <- matrix(NA,K*2,R)
    sigma.boot <- matrix(NA,K*4,R)
    for (b in 1:R)
    {
      true.par <- hmmspec(init = mod.hmm$model$init,
                          trans = mod.hmm$model$transition,
                          parms.emis = list(mu = mod.hmm$model$parms.emission$mu,
                                            sigma = mod.hmm$model$parms.emission$sigma),
                          dens.emis = dmvnorm.hsmm)
      mod.boot <- hmmfit(matrix(unlist(data)), true.par, mstep = mstep.mvnorm)
      mu.boot[,b] <- unlist(mod.boot$model$parms.emission$mu)
      sigma.boot[,b] <- unlist(mod.boot$model$parms.emission$sigma)
    }



    return(list(k = num,
                model = mod.hmm,
                means.mean = t(matrix(apply(mu.boot,1,mean),ncol = K*2)),
                means.sd = t(matrix(apply(mu.boot,1,sd),ncol = K*2)),
                sigma.mean = t(matrix(apply(sigma.boot,1,mean),ncol = K*2**2)),
                sigma.sd = t(matrix(apply(sigma.boot,1,sd),ncol = K*2**2)),
                AIC=hsmmAIC(mod.hmm),
                BIC=hsmmBIC(mod.hmm)))

  },length(master))
  stopCluster(cl)
  return(master)
}

load("~/N-HMM-2-4.RData")
```

```{r logLik HMM}
par(mfrow=c(3,1))
plot(HMM[[1]]$model$loglik, 
     type = "b", 
     ylab="Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="2 states LogLik")
plot(HMM[[2]]$model$loglik, 
     type = "b",
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="3 states LogLik")
plot(HMM[[3]]$model$loglik, 
     type = "b", 
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="4 states LogLik")
```
```{r yhat-HMM}
plot(newDF[,1],
     col=HMM[[1]]$model$yhat,
     main = "2 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=HMM[[2]]$model$yhat,
     main = "3 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=HMM[[3]]$model$yhat,
     main = "4 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
```


```{r NASDAQ-HMM, message=FALSE, warning=FALSE, paged.print=TRUE}
p1<-ggplot(StockReturns2, aes(x=NASDAQ)) +
  geom_histogram(aes(y =..density..),
                 color="black", fill="white", binwidth=.1) +
  theme_minimal()+
  stat_function(fun = dnorm, args = list(mean = HMM[[1]]$means.mean[1],
                                         sd = HMM[[1]]$sigma.mean[1]), colour="red")+
  stat_function(fun = dnorm, args = list(mean = HMM[[1]]$means.mean[3],
                                         sd = HMM[[1]]$sigma.mean[5]), colour="green")

p2<-ggplot(StockReturns2, aes(x=NASDAQ)) +
  geom_histogram(aes(y =..density..),
                 color="black", fill="white", binwidth=.1) +
  theme_minimal()+
  stat_function(fun = dnorm, args = list(mean = HMM[[2]]$means.mean[1],
                                         sd = HMM[[2]]$sigma.mean[1]), colour="red")+
  stat_function(fun = dnorm, args = list(mean = HMM[[2]]$means.mean[3],
                                         sd = HMM[[2]]$sigma.mean[5]), colour="green")+
  stat_function(fun = dnorm, args = list(mean = HMM[[2]]$means.mean[5],
                                         sd = HMM[[2]]$sigma.mean[9]), colour="yellow")

p3<-ggplot(StockReturns2, aes(x=NASDAQ)) +
  geom_histogram(aes(y =..density..),
                 color="black", fill="white", binwidth=.1) +
  theme_minimal()+
  stat_function(fun = dnorm, args = list(mean = HMM[[3]]$model$model$parms.emission$mu[[1]][1],
                                         sd = HMM[[3]]$model$model$parms.emission$sigma[[1]][1]), colour="red")+
  stat_function(fun = dnorm, args = list(mean = HMM[[3]]$model$model$parms.emission$mu[[2]][1],
                                         sd = HMM[[3]]$model$model$parms.emission$sigma[[2]][1]), colour="green")+
  stat_function(fun = dnorm, args = list(mean = HMM[[3]]$model$model$parms.emission$mu[[3]][1],
                                         sd = HMM[[3]]$model$model$parms.emission$sigma[[3]][1]), colour="yellow")+
  stat_function(fun = dnorm, args = list(mean = HMM[[3]]$model$model$parms.emission$mu[[4]][1],
                                         sd = HMM[[3]]$model$model$parms.emission$sigma[[4]][1]), colour="blue")

grid.arrange(p1, p2, p3, ncol=1)
```

# HSMM
## Poisson SD
```{r N-HSMM-Poisson}
bootstrap.N.HSMM.POISSON <- function(data, nclust, R) {
  master = list()
  cores <- ifelse(detectCores() > 6,
                  cores <- 6,
                  cores <- 4)
  cl <- makeCluster(cores)
  registerDoParallel(cl)
  master <- append(master, foreach(num = 2:nclust) %dopar% {
    require(mhsmm)

    hsmmAIC <- function(model) {
      if (class(model) == 'hmm') {
        m = model$K
      } else if (class(model) == 'hsmm') {
        m = model$J
      }
      k = length(model$model$parms.emission)
      p = m ^ 2 + (k * m) - 1
      logL = max(model$loglik)
      AIC = (2 * logL) + (2 * p)
      return(AIC)
    }

    hsmmBIC <- function(model) {
      if (class(model) == 'hmm') {
        m = model$K
      } else if (class(model) == 'hsmm') {
        m = model$J
      }
      nObs = length(model$yhat)
      k = length(model$model$parms.emission)
      p = (m ^ 2 + (k * m)) - 1
      logL = max(model$loglik)
      BIC = (2 * logL) + (p * log(nObs))
      return(BIC)
    }

    initialization <- kmeans(data, num)
    kmeans.means <- initialization$centers
    km.means.list = list()
    sigma.list = list()

    for (n in 1:num) {
      sigma.list[[n]] = cov(data[initialization$cluster == n, ])
      km.means.list[[n]] = kmeans.means[n, ]
    }

    K <- num
    init <- rep(1 / K, K)
    P <- matrix(1 / (K - 1), ncol = K, nrow = K)
    diag(P) <- 0
    B <- list(mu = km.means.list,
              sigma = sigma.list)

    d <-list(
      lambda = sample(1:500, K),
      shift = sample(10:100, K),
      type = "poisson")


    start.val <- hsmmspec(
      init = init,
      transition = P,
      parms.emis = B,
      sojourn = d,
      dens.emis = dmvnorm.hsmm,
      mstep = mstep.mvnorm)

    mod.hsmm <- hsmmfit(matrix(unlist(data),ncol = 2),
                        start.val, mstep = mstep.mvnorm)
    mu.boot <- matrix(NA, K * 2, R)
    sigma.boot <- matrix(NA, K * 4, R)
    for (b in 1:R){
      true.par <- hsmmspec(
        init = mod.hsmm$model$init,
        transition = mod.hsmm$model$transition,
        parms.emis = list(
          mu = mod.hsmm$model$parms.emission$mu,
          sigma = mod.hsmm$model$parms.emission$sigma),
        sojourn = list(
          lambda = mod.hsmm$model$sojourn$lambda,
          shift = mod.hsmm$model$sojourn$shift,
          type = mod.hsmm$model$sojourn$type),
        dens.emis = dmvnorm.hsmm,
        mstep = mstep.mvnorm)
      mod.boot <- hsmmfit(matrix(unlist(data),ncol=2), true.par, mstep = mstep.mvnorm)
      mu.boot[, b] <- unlist(mod.boot$model$parms.emission$mu)
      sigma.boot[, b] <- unlist(mod.boot$model$parms.emission$sigma)
    }

    return(list(
      k = num,
      model = mod.hsmm,
      means.mean = t(matrix(apply(mu.boot, 1, mean), ncol = K * 2)),
      means.sd = t(matrix(apply(mu.boot, 1, sd), ncol = K * 2)),
      sigma.mean = t(matrix(apply(sigma.boot, 1, mean), ncol = K * 2 ** 2)),
      sigma.sd = t(matrix(apply(sigma.boot, 1, sd), ncol = K * 2 ** 2)),
      AIC = hsmmAIC(mod.hsmm),
      BIC = hsmmBIC(mod.hsmm)))
  }, length(master))

  stopCluster(cl)
  return(master)
}
load("~/data/N-HSMM-2-4-Poisson.RData")
```

```{r logLik HSMM-Poisson}
par(mfrow=c(3,1))
plot(HSMM[[1]]$model$loglik, 
     type = "b", 
     ylab="Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="2 states LogLik")
plot(HSMM[[2]]$model$loglik, 
     type = "b",
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="3 states LogLik")
plot(HSMM[[3]]$model$loglik, 
     type = "b", 
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="4 states LogLik")
```
```{r Poisson-SD}
par(mfrow=c(3,1))
plot(HSMM[[1]]$model,xlim=c(0,550))
plot(HSMM[[2]]$model,xlim=c(0,550))
plot(HSMM[[3]]$model,xlim=c(0,550))
```

```{r yhat-HSMM-Poisson}
plot(newDF[,1],
     col=HSMM[[1]]$model$yhat,
     main = "2 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=HSMM[[2]]$model$yhat,
     main = "3 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=HSMM[[3]]$model$yhat,
     main = "4 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
```

## Gamma SD

```{r N-HSMM-Gamma}
bootstrap.N.HSMM.GAMMA <- function(data, nclust, R) {
  master = list()
  cores <- ifelse(detectCores() > 6,
                  cores <- 6,
                  cores <- 4)
  cl <- makeCluster(cores)
  registerDoParallel(cl)
  master <- append(master, foreach(num = 2:nclust) %dopar% {
    require(mhsmm)
    
    hsmmAIC <- function(model) {
      if (class(model) == 'hmm') {
        m = model$K
      } else if (class(model) == 'hsmm') {
        m = model$J
      }
      k = length(model$model$parms.emission)
      p = m ^ 2 + (k * m) - 1
      logL = max(model$loglik)
      AIC = (2 * logL) + (2 * p)
      return(AIC)
    }
    
    hsmmBIC <- function(model) {
      if (class(model) == 'hmm') {
        m = model$K
      } else if (class(model) == 'hsmm') {
        m = model$J
      }
      nObs = length(model$yhat)
      k = length(model$model$parms.emission)
      p = (m ^ 2 + (k * m)) - 1
      logL = max(model$loglik)
      BIC = (2 * logL) + (p * log(nObs))
      return(BIC)
    }
    
    initialization <- kmeans(data, num)
    kmeans.means <- initialization$centers
    km.means.list = list()
    sigma.list = list()
    
    for (n in 1:num) {
      sigma.list[[n]] = cov(data[initialization$cluster == n, ])
      km.means.list[[n]] = kmeans.means[n, ]
    }
    
    K <- num
    P <- matrix(1 / (K - 1), ncol = K, nrow = K)
    diag(P) <- 0
    start.val <- hsmmspec(
      init = rep(1 / K, K),
      
      transition = P,
      
      parms.emis = list(mu = km.means.list,
                        sigma = sigma.list),
      
      sojourn = list(shape = c(1,2,3),
                     scale = c(1,2,3),
                     type = "gamma"),
      
      dens.emis = dmvnorm.hsmm,
      
      mstep = mstep.mvnorm)
    
    mod.hsmm <- hsmmfit(matrix(unlist(data),ncol = 2),
                        start.val, mstep = mstep.mvnorm)
    mu.boot <- matrix(NA, K * 2, R)
    sigma.boot <- matrix(NA, K * 4, R)
    for (b in 1:R){
      
      true.par <- hsmmspec(
        init = mod.hsmm$model$init,
        transition = mod.hsmm$model$transition,
        parms.emis = list(
          mu = mod.hsmm$model$parms.emission$mu,
          sigma = mod.hsmm$model$parms.emission$sigma),
        sojourn = list(
          shape = mod.hsmm$model$sojourn$shape,
          scale = mod.hsmm$model$sojourn$scale,
          type = mod.hsmm$model$sojourn$type),
        dens.emis = dmvnorm.hsmm,
        mstep = mstep.mvnorm)
      
      mod.boot <- hsmmfit(matrix(unlist(data),ncol=2), true.par, mstep = mstep.mvnorm)
      mu.boot[, b] <- unlist(mod.boot$model$parms.emission$mu)
      sigma.boot[, b] <- unlist(mod.boot$model$parms.emission$sigma)
    }
    
    return(list(
      k = num,
      model = mod.hsmm,
      means.mean = matrix(apply(mu.boot, 1, mean), ncol = K * 2),
      means.sd = mu.boot,
      sigma.mean = matrix(apply(sigma.boot, 1, mean), ncol = K * 2 ** 2),
      sigma.sd = sigma.boot,
      AIC = hsmmAIC(mod.hsmm),
      BIC = hsmmBIC(mod.hsmm)))
  }, length(master))
  
  stopCluster(cl)
  return(master)
}
load("~/data/N-HSMM-2-4-Gamma.RData")
```

```{r logLik HSMM-Gamma}
par(mfrow=c(3,1))
plot(GAMMA.HSMM[[1]]$model$loglik, 
     type = "b", 
     ylab="Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="2 states LogLik")
plot(GAMMA.HSMM[[2]]$model$loglik, 
     type = "b",
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="3 states LogLik")
plot(GAMMA.HSMM[[3]]$model$loglik, 
     type = "b", 
     ylab = "Log-likelihood",
     xlab="Iteration", 
     xlim=c(0,30),
     main="4 states LogLik")
```

```{r Gamma-SD}
par(mfrow=c(3,1))
plot(GAMMA.HSMM[[1]]$model,xlim=c(0,100))
plot(GAMMA.HSMM[[2]]$model,xlim=c(0,100))
plot(GAMMA.HSMM[[3]]$model,xlim=c(0,100))
```

```{r yhat-HSMM-Gamma}
plot(newDF[,1],
     col=GAMMA.HSMM[[1]]$model$yhat,
     main = "2 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=GAMMA.HSMM[[2]]$model$yhat,
     main = "3 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
plot(newDF[,1],
     col=GAMMA.HSMM[[3]]$model$yhat,
     main = "4 states N-HMM",
     xlab="Obs",
     ylab=colnames(newDF)[1])
```
