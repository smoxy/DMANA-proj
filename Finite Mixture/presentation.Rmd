---
title: "Multivariate data analysis: a discriminating method of the origin of wines"
output: html_notebook
author: 'Matteo Fasulo, Simone Flavio Paris, Matteo Sivoccia'
---
```{r loadEnv, message=FALSE, warning=FALSE}
source("https://raw.githubusercontent.com/MatteoFasulo/Rare-Earth/main/R/util/coreFunctions.R")
loadPackages(c('sn','tidyverse','car','RColorBrewer','stargazer','mclust','ContaminatedMixt',
               'plotly','ggplot2','ggdendro','pgmm','teigen','tclust','HDMD'))
load("Z:\\DesktopC\\LUMSA\\2\\Data Mining\\Finite Mixture\\FiniteMixtureL31.RData")
rm(CO2data)
rm(NOdata)
rm(tonedata)
type <- wine$Type
rm(wine)
```
Dati su 27 caratteristiche chimico/fisiche di tre diversi tipi di vino (Barolo, Grignolino, Barbera)
dal Piemonte. Un set di dati con 178 osservazioni e 28 variabili (di cui la prima relativa alla tipologia di vino). Nell'ordine: 

- Barolo 
- Grignolino
- Barbera

E' stato possibile attraverso la ricerca originaria risalire all'anno di osservazione di ciascun vino. Di seguito vengono riportate le osservazioni dei tre diversi tipi di vino durante gli anni:

```{r vinoAnni, message=FALSE, warning=FALSE}
data(wines)
year <- as.numeric(substr(rownames(wines), 6, 7))
table(wines$wine, year)
```

Per quanto riguarda la numerositÃ  delle singole classi:

```{r nClassi, message=FALSE, warning=FALSE}
wines %>%
  count(wine = factor(wine)) %>%
  mutate(pct = prop.table(n)) %>% 
  ggplot(aes(x = wine, y = pct, fill = wine, label = scales::percent(pct))) + 
  geom_col(position = 'dodge') + 
  geom_text(position = position_dodge(width = .9),
            vjust = -0.5, 
            size = 3) + 
  scale_y_continuous(name = "Percentage")+
  scale_x_discrete(name = "Wine Name")+
  scale_fill_hue(l=40, c=35)+
  theme(legend.position = "none")
```


```{r scatterPlot, message=FALSE, warning=FALSE}
wines[,'wine'] <- type # fix wine name in numeric
scatterplotMatrix(wines[2:10])
scatterplotMatrix(wines[11:20])
scatterplotMatrix(wines[21:28])
```
Nella *matrix scatterplot*, le celle sulla diagonale mostrano gli istogrammi di ognuna delle variabili, in questo caso le concentrazioni delle prime 10 caratteristiche chimiche. Ognuna delle celle fuori dalla diagonale, rappresenta lo scatterplot di 2 delle 10 caratteristiche.
```{r descriptive, message=FALSE, warning=FALSE}
printMeanAndSdByGroup <- function(variables,groupvariable)
  {
     variablenames <- c(names(groupvariable),names(as.data.frame(variables)))
     groupvariable <- groupvariable[,1]
     means <- aggregate(as.matrix(variables) ~ groupvariable, FUN = mean)
     names(means) <- variablenames
     print(paste("Means:"))
     print(means)
     sds <- aggregate(as.matrix(variables) ~ groupvariable, FUN = sd)
     names(sds) <- variablenames
     print(paste("Standard deviations:"))
     print(sds)
}
printMeanAndSdByGroup(wines[2:28],wines[1])
```

```{r withinVariance, message=FALSE, warning=FALSE}
calcWithinGroupsVariance <- function(variable,groupvariable)
  {
     # find out how many values the group variable can take
     groupvariable2 <- as.factor(groupvariable[[1]])
     levels <- levels(groupvariable2)
     numlevels <- length(levels)
     # get the mean and standard deviation for each group:
     numtotal <- 0
     denomtotal <- 0
     for (i in 1:numlevels)
     {
        leveli <- levels[i]
        levelidata <- variable[groupvariable==leveli,]
        levelilength <- length(levelidata)
        # get the standard deviation for group i:
        sdi <- sd(levelidata)
        numi <- (levelilength - 1)*(sdi * sdi)
        denomi <- levelilength
        numtotal <- numtotal + numi
        denomtotal <- denomtotal + denomi
     }
     # calculate the within-groups variance
     Vw <- numtotal / (denomtotal - numlevels)
     return(Vw)
}
calcWithinGroupsVariance(wines[2],wines[1])
```
```{r betweenVariance}
calcBetweenGroupsVariance <- function(variable,groupvariable)
  {
     # find out how many values the group variable can take
     groupvariable2 <- as.factor(groupvariable[[1]])
     levels <- levels(groupvariable2)
     numlevels <- length(levels)
     # calculate the overall grand mean:
     grandmean <- sapply(variable,mean)
     # get the mean and standard deviation for each group:
     numtotal <- 0
     denomtotal <- 0
     for (i in 1:numlevels)
     {
        leveli <- levels[i]
        levelidata <- variable[groupvariable==leveli,]
        levelilength <- length(levelidata)
        # get the mean and standard deviation for group i:
        meani <- mean(levelidata)
        sdi <- sd(levelidata)
        numi <- levelilength * ((meani - grandmean)^2)
        denomi <- levelilength
        numtotal <- numtotal + numi
        denomtotal <- denomtotal + denomi
     }
     # calculate the between-groups variance
     Vb <- numtotal / (numlevels - 1)
     Vb <- Vb[[1]]
     return(Vb)
}
calcBetweenGroupsVariance (wines[2],wines[1])
```

```{r dldldl, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}
# DISTANCE
x.euclidean   <- dist(scale(wines[,-1]), method="euclidean")
dissMatrix    <- as.dist(pairwise.mahalanobis(wines[,-1], grouping = c(1:nrow(wines)), cov = cov(wines[,-1]))$distance)
eucl.hc.ward  <- hclust(x.euclidean,method="ward.D2")
maha.hc.ward  <- hclust(dissMatrix,method="ward.D2")

ggplotly(ggdendrogram(eucl.hc.ward, rotate = F, size = 2, leaf_labels = T, labels = F))
hicluste3=cutree(eucl.hc.ward,k=3)
table(wines[,1],hicluste3)
hicluste1=cutree(eucl.hc.ward,k=4)
table(wines[,1],hicluste1)

ggplotly(ggdendrogram(maha.hc.ward, rotate = F, size = 2, leaf_labels = T, labels = F))
hicluste4=cutree(maha.hc.ward,k=3)
table(wines[,1],hicluste4)
hicluste2=cutree(maha.hc.ward,k=4)
table(wines[,1],hicluste2)

k.means.3 <- kmeans(scale(wines[,-1]),centers=3,nstart = 50, iter.max = 100)
k.means.4 <- kmeans(scale(wines[,-1]),centers=4,nstart = 50, iter.max = 100)

mixt.wines <- Mclust(wines[,-1],G=3:8)                                  # EM Alg for Finite gaussian mixture models
mixt.cn.wines.mixt.3 <- CNmixt(wines[,-1], G = 3, initialization = "mixt", seed = 1234, parallel = F, verbose = F)
mixt.cn.wines.kmeans <- CNmixt(wines[,-1], G = 3, initialization = "kmeans", seed = 1234, parallel = F, verbose = F)
mixt.cn.wines.rpost <- CNmixt(wines[,-1], G = 3, initialization = "random.post", seed = 1234, parallel = F, verbose = F)
mixt.cn.wines.rclass <- CNmixt(wines[,-1], G = 3, initialization = "random.clas", seed = 1234, parallel = F, verbose = F)

agree(mixt.cn.wines.mixt.3, givgroup = wines[,1])
agree(mixt.cn.wines.kmeans, givgroup = wines[,1])
agree(mixt.cn.wines.rpost, givgroup = wines[,1])
agree(mixt.cn.wines.rclass, givgroup = wines[,1])
plot(mixt.cn.wines.mixt.3, contours = TRUE)

table(wines[,1],k.means$cluster)
adjustedRandIndex(wines[,1],k.means$cluster)
table(wines[,1],mixt.wines$classification)
adjustedRandIndex(wines[,1],mixt.wines$classification)

whichBestModel <- function(contaminatedModel, dataset){
  n.models <- length(contaminatedModel$models)
  maxAdjRIndex <- -Inf
  bestModel <- NULL
  fit <- NULL
  G <- NULL
  bic <- NULL
  icl <- NULL
  contaminated <- NULL
  for (i in 1:n.models){
    if (adjustedRandIndex(dataset,contaminatedModel$models[[i]]$group) > maxAdjRIndex){
      maxAdjRIndex <- adjustedRandIndex(dataset,contaminatedModel$models[[i]]$group)
      bestModel <- contaminatedModel$models[[i]]$model
      result <- contaminatedModel$models[[i]]$group
      fit <- table(dataset,contaminatedModel$models[[i]]$group)
      G <- contaminatedModel$models[[i]]$G
      contaminated <-contaminatedModel$models[[i]]$contamination
      bestI <- i
      bic <- contaminatedModel$models[[i]]$IC$BIC
      icl <- contaminatedModel$models[[i]]$IC$ICL
    }
  }
  return(list(result = result,
              modelNum = bestI, 
              comingModel = bestModel, 
              G = G, 
              isContaminated = contaminated, 
              fit = fit, 
              AdjustedRandIndex = maxAdjRIndex,
              BIC = bic,
              ICL = icl))
}
whichBestModel(mixt.cn.wines, wines[,1])
```

```{r summaryOfAllModel, message=FALSE, warning=FALSE}
summaryOfModels <- function(df, models){
  require(mclust)
  nModel <- length(models)
  ari <- NULL
  bic <- NULL
  icl <- NULL
  G <- NULL
  for(i in 1:nModel){
           if (class(models[[i]])=='kmeans'){
      ari[i] <- adjustedRandIndex(df,models[[i]]$cluster)
      bic[i] <- NA
      icl[i] <- NA
      G[i] <- length(unique(models[[i]]$cluster))
    } else if (class(models[[i]])=='Mclust'){
      ari[i] <- adjustedRandIndex(df,models[[i]]$classification)
      bic[i] <- models[[i]]$bic
      icl[i] <- models[[i]]$icl
      G[i] <- models[[i]]$G
    } else if (class(models[[i]])=='ContaminatedMixt'){
      ari[i] <- adjustedRandIndex(df,whichBestModel(models[[i]],df)$result)
      bic[i] <- whichBestModel(models[[i]],df)$BIC
      icl[i] <- whichBestModel(models[[i]],df)$ICL
      G[i] <- whichBestModel(models[[i]],df)$G
    } else if (class(models[[i]])=='teigen'){
      ari[i] <- adjustedRandIndex(df,models[[i]]$iclresults$classification)
      bic[i] <- models[[i]]$bic
      icl[i] <- models[[i]]$iclresults$icl
      G[i] <- models[[i]]$G
    } else if (class(models[[i]])=='pgmm'){
      ari[i] <- adjustedRandIndex(df,models[[i]]$map)
      G[i] <- models[[i]]$g
      ifelse(is.null(models[[i]]$bic[1])==TRUE,
             bic[i] <- NA,
             bic[i] <- as.double(models[[i]]$bic[1]))
      ifelse(is.null(models[[i]]$icl[1])==TRUE,
             icl[i] <- NA,
             icl[i] <- as.double(models[[i]]$icl[1]))
    } else if (class(models[[i]])=='tkmeans'){
      ari[i] <- adjustedRandIndex(df,models[[i]]$cluster)
      G[i] <- models[[i]]$k
      bic[i] <- NA
      icl[i] <- NA
    }
  }
  outputDF <- data.frame('AdjustedRandIndex' = ari,
                         'BIC' = bic,
                         'ICL' = icl,
                         'G' = as.integer(G),
                         row.names = c('KMeans','Mclust','ContaminatedMixt','TEigen','PGMM','TClust'),
                         stringsAsFactors = F)
  return(outputDF)
}
test <- summaryOfModels(wines[,1],list(k.means,mixt.wines,mixt.cn.wines,teigen_wine,pippo,trimmedOne))
test
```
